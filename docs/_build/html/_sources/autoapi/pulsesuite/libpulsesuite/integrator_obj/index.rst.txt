:py:mod:`pulsesuite.libpulsesuite.integrator_obj`
=================================================

.. py:module:: pulsesuite.libpulsesuite.integrator_obj

.. autoapi-nested-parse::

   Integrator module (Python version)
   ==================================
   High-performance ODE integrators for scientific computing, ported from Fortran.

   Dependencies: numpy, numba, guardrails, nrutils

   Implements: Adaptive-step integrators for real (float64) and complex (complex128) ODEs,
   including Cash–Karp RKQS single-step routines and dummy Jacobians.

   Author: Rahul R. Sah



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   pulsesuite.libpulsesuite.integrator_obj.Integrator
   pulsesuite.libpulsesuite.integrator_obj.ComplexIntegrator
   pulsesuite.libpulsesuite.integrator_obj.Complex3DIntegrator



Functions
~~~~~~~~~

.. autoapisummary::

   pulsesuite.libpulsesuite.integrator_obj.rk4_dp
   pulsesuite.libpulsesuite.integrator_obj.rk4_dpc
   pulsesuite.libpulsesuite.integrator_obj.idiot_dp
   pulsesuite.libpulsesuite.integrator_obj.idiot_dpc
   pulsesuite.libpulsesuite.integrator_obj.rkck_dp
   pulsesuite.libpulsesuite.integrator_obj.rkck_dpc
   pulsesuite.libpulsesuite.integrator_obj.rkqs_dp
   pulsesuite.libpulsesuite.integrator_obj.rkqs_dpc
   pulsesuite.libpulsesuite.integrator_obj.mmid
   pulsesuite.libpulsesuite.integrator_obj.pzextr
   pulsesuite.libpulsesuite.integrator_obj.bsstep
   pulsesuite.libpulsesuite.integrator_obj.simpr
   pulsesuite.libpulsesuite.integrator_obj.stifbs
   pulsesuite.libpulsesuite.integrator_obj.ludcmp
   pulsesuite.libpulsesuite.integrator_obj.lubksb
   pulsesuite.libpulsesuite.integrator_obj.odeint_3D_dpc
   pulsesuite.libpulsesuite.integrator_obj.odeint_3D_dpc_TOM



Attributes
~~~~~~~~~~

.. autoapisummary::

   pulsesuite.libpulsesuite.integrator_obj.SAFETY
   pulsesuite.libpulsesuite.integrator_obj.PGROW
   pulsesuite.libpulsesuite.integrator_obj.PSHRNK
   pulsesuite.libpulsesuite.integrator_obj.ERRCON
   pulsesuite.libpulsesuite.integrator_obj.TINY
   pulsesuite.libpulsesuite.integrator_obj.MAXSTP
   pulsesuite.libpulsesuite.integrator_obj.KMAXX
   pulsesuite.libpulsesuite.integrator_obj.rkck_3D_dpc
   pulsesuite.libpulsesuite.integrator_obj.rk4_3D_dpc


.. py:data:: SAFETY
   :value: 0.9

   

.. py:data:: PGROW

   

.. py:data:: PSHRNK

   

.. py:data:: ERRCON

   

.. py:data:: TINY
   :value: 1e-30

   

.. py:data:: MAXSTP
   :value: 100000000

   

.. py:data:: KMAXX
   :value: 8

   

.. py:function:: rk4_dp(y: numpy.ndarray, dydt: numpy.ndarray, t: float, h: float, D: Callable[[float, numpy.ndarray], numpy.ndarray]) -> Tuple[numpy.ndarray, float]


.. py:function:: rk4_dpc(y: numpy.ndarray, dydt: numpy.ndarray, t: float, h: float, D: Callable[[float, numpy.ndarray], numpy.ndarray]) -> Tuple[numpy.ndarray, float]


.. py:function:: idiot_dp(y: numpy.ndarray, dydt: numpy.ndarray, t: float, h: float, D: Callable[[float, numpy.ndarray], numpy.ndarray]) -> Tuple[numpy.ndarray, float]


.. py:function:: idiot_dpc(y: numpy.ndarray, dydt: numpy.ndarray, t: float, h: float, D: Callable[[float, numpy.ndarray], numpy.ndarray]) -> Tuple[numpy.ndarray, float]


.. py:function:: rkck_dp(y: numpy.ndarray, dydt: numpy.ndarray, t: float, h: float, D: Callable[[float, numpy.ndarray], numpy.ndarray]) -> Tuple[numpy.ndarray, numpy.ndarray]

   Cash–Karp single-stage for real ODEs: returns (yout, yerr).


.. py:function:: rkck_dpc(y: numpy.ndarray, dydt: numpy.ndarray, t: float, h: float, D: Callable[[float, numpy.ndarray], numpy.ndarray]) -> Tuple[numpy.ndarray, numpy.ndarray]

   Cash–Karp single-stage for complex ODEs: returns (yout, yerr).


.. py:function:: rkqs_dp(y: numpy.ndarray, dydt: numpy.ndarray, t: float, htry: float, eps: float, yscale: numpy.ndarray, D: Callable) -> Tuple[numpy.ndarray, float, float, float]

   Adaptive Runge–Kutta step control (Cash–Karp) for real ODEs.
   Returns (y, tnew, hdid, hnext).


.. py:function:: rkqs_dpc(y: numpy.ndarray, dydt: numpy.ndarray, t: float, htry: float, eps: float, yscale: numpy.ndarray, D: Callable) -> Tuple[numpy.ndarray, float, float, float]

   Adaptive Runge–Kutta step control (Cash–Karp) for complex ODEs.
   Returns (y, tnew, hdid, hnext).


.. py:function:: mmid(y: numpy.ndarray, dydx: numpy.ndarray, xs: float, htot: float, nstep: int, D: Callable[[float, numpy.ndarray], numpy.ndarray]) -> numpy.ndarray


.. py:function:: pzextr(iest, xest, yest, yz, dy)


.. py:function:: bsstep(y: numpy.ndarray, dydx: numpy.ndarray, x: float, htry: float, eps: float, yscale: numpy.ndarray, D: Callable[[float, numpy.ndarray], numpy.ndarray], jacobn: Callable[[float, numpy.ndarray], Tuple[numpy.ndarray, numpy.ndarray]]) -> Tuple[numpy.ndarray, float, float]

   Bulirsch–Stoer step using modified midpoint (mmid) and Richardson extrapolation (pzextr).


.. py:function:: simpr(y: numpy.ndarray, dydx: numpy.ndarray, dfdx: numpy.ndarray, dfdy: numpy.ndarray, xs: float, htot: float, nstep: int, derivs: Callable[[float, numpy.ndarray], numpy.ndarray]) -> numpy.ndarray

   Semi-implicit predictor-corrector step for Bulirsch–Stoer.
   Builds A = I – h*dfdy, factors it once, then performs predictor+corrector
   across nstep sub-intervals.


.. py:function:: stifbs(y: numpy.ndarray, dydx: numpy.ndarray, x: float, htry: float, eps: float, yscal: numpy.ndarray, derivs: Callable[[float, numpy.ndarray], numpy.ndarray], jacobn: Callable[[float, numpy.ndarray], Tuple[numpy.ndarray, numpy.ndarray]]) -> Tuple[float, float, float]

   Single step of the stiff Bulirsch–Stoer algorithm.
   Returns (x_new, h_used, h_next).


.. py:function:: ludcmp(a: numpy.ndarray, indx: numpy.ndarray) -> float

   Wrapper around LAPACK’s DGETRF via SciPy.

   Overwrites `a` in place with the combined L and U factors,
   fills `indx` with the pivot indices (0-based),
   and returns +1.0 or –1.0 depending on the parity of row swaps.


.. py:function:: lubksb(a: numpy.ndarray, indx: numpy.ndarray, b: numpy.ndarray) -> None

   Wrapper around LAPACK’s DGETRS via SciPy.

   Solves A·x = b in two steps using the LU factors in `a`
   and pivot array `indx`.  Overwrites `b` with the solution.


.. py:function:: odeint_3D_dpc(y, x1, x2, eps, h1, hmin, D, integ)


.. py:data:: rkck_3D_dpc

   

.. py:data:: rk4_3D_dpc

   

.. py:function:: odeint_3D_dpc_TOM(y, x1, x2, eps, h1, hmin, D, integ)


.. py:class:: Integrator(deriv: Callable[[float, numpy.typing.NDArray[numpy.float64]], numpy.typing.NDArray[numpy.float64]], stepper: Callable, jacobian: Callable[[float, numpy.typing.NDArray[numpy.float64]], Tuple[numpy.typing.NDArray[numpy.float64], numpy.typing.NDArray[numpy.float64]]], h1: float, hmin: float)


   Adaptive ODE integrator for real (float64) problems.

   .. py:method:: solve_dp(y0: Annotated[numpy.typing.NDArray[numpy.float64], numpy.float64], x1: Annotated[float, numpy.float64], x2: Annotated[float, numpy.float64], eps: Annotated[float, numpy.float64]) -> Tuple[numpy.typing.NDArray[numpy.float64], numpy.int32, numpy.int32]



.. py:class:: ComplexIntegrator(deriv: Callable[[float, numpy.typing.NDArray[numpy.complex128]], numpy.typing.NDArray[numpy.complex128]], stepper: Callable, jacobian: Callable[[float, numpy.typing.NDArray[numpy.complex128]], Tuple[numpy.typing.NDArray[numpy.complex128], numpy.typing.NDArray[numpy.complex128]]], h1: float, hmin: float)


   Bases: :py:obj:`Integrator`

   Adaptive ODE integrator for complex (complex128) problems.

   .. py:method:: solve_dpc(y0: Annotated[numpy.typing.NDArray[numpy.complex128], numpy.complex128], x1: Annotated[float, numpy.float64], x2: Annotated[float, numpy.float64], eps: Annotated[float, numpy.float64]) -> Tuple[numpy.typing.NDArray[numpy.complex128], numpy.int32, numpy.int32]



.. py:class:: Complex3DIntegrator(deriv, stepper, h1, hmin)


   .. py:method:: solve_dpc_3D(y0: numpy.typing.NDArray[numpy.complex128], x1: float, x2: float, eps: float)


   .. py:method:: solve_dpc_3D_TOM(y0: numpy.typing.NDArray[numpy.complex128], x1: float, x2: float, eps: complex)



