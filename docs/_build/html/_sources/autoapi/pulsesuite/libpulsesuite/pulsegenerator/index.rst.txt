:py:mod:`pulsesuite.libpulsesuite.pulsegenerator`
=================================================

.. py:module:: pulsesuite.libpulsesuite.pulsegenerator

.. autoapi-nested-parse::

   Author: Rahul R. Sah



Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   pulsesuite.libpulsesuite.pulsegenerator.FilePulse
   pulsesuite.libpulsesuite.pulsegenerator.pulsegen2
   pulsesuite.libpulsesuite.pulsegenerator.pulsegen1
   pulsesuite.libpulsesuite.pulsegenerator.multipulsegen



.. py:function:: FilePulse(fn: str, X: Annotated[numpy.ndarray, numpy.float64]) -> Annotated[numpy.ndarray, numpy.complex128]

   Read a user-defined pulse from file and resample onto X.

   :param fn: Path to file containing matrix P.
   :type fn: str
   :param X: Target grid for interpolation.
   :type X: float64 ndarray

   :returns: **Y** -- Pulse values at X.
   :rtype: complex128 ndarray


.. py:function:: pulsegen2(shp: str, FWHM: Annotated[float, numpy.float64], X: Annotated[numpy.ndarray, numpy.float64]) -> Annotated[numpy.ndarray, numpy.complex128]

   Core pulse generator: dispatch by shape.

   :param shp: Shape key ("gauss", "sech2", "square", "file:<fn>").
   :type shp: str
   :param FWHM: Width parameter for built-in shapes.
   :type FWHM: float64
   :param X: Sample grid.
   :type X: float64 ndarray

   :returns: **Y** -- Pulse values.
   :rtype: complex128 ndarray


.. py:function:: pulsegen1(shp: str, FWHM: Annotated[float, numpy.float64], N: Annotated[int, numpy.int32], dx: Annotated[float, numpy.float64], X_out: Optional[Annotated[numpy.ndarray, numpy.float64]] = None) -> Tuple[Annotated[numpy.ndarray, numpy.complex128], Annotated[numpy.ndarray, numpy.float64]]

   Top-level pulse generator: build grid + call pulsegen2.

   :param shp: Shape key.
   :type shp: str
   :param FWHM: Width parameter.
   :type FWHM: float64
   :param N: Number of samples.
   :type N: int32
   :param dx: Grid spacing.
   :type dx: float64
   :param X_out: If provided, filled with grid.
   :type X_out: float64 ndarray, optional

   :returns: * **Y** (*complex128 ndarray*)
             * **X** (*float64 ndarray*)


.. py:function:: multipulsegen(shp: str, t0: Annotated[float, numpy.float64], t: Annotated[numpy.ndarray, numpy.float64], sep: Annotated[float, numpy.float64], num: Annotated[int, numpy.int32]) -> Annotated[numpy.ndarray, numpy.complex128]

   Generate 2 or 3 pulses on grid t.

   :param shp: "gauss", "uneven2a", "uneven2b", or else sech.
   :type shp: str
   :param t0: Pulse width/scale.
   :type t0: float64
   :param t: Time grid.
   :type t: float64 ndarray
   :param sep: Separation.
   :type sep: float64
   :param num: Number of pulses (2 or 3).
   :type num: int32

   :returns: **y**
   :rtype: complex128 ndarray


